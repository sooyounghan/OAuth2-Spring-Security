-----
### OpenID Connect 1.0 Provider Configuration Endpoint
-----
1. OidcConfigurerëŠ” OpenID Connect 1.0 Provider Configuration (Oidc Metadata) ì—”ë“œí¬ì¸íŠ¸ì— ëŒ€í•œ ì§€ì› ì œê³µ
2. OidcConfigurerëŠ” OidcProviderConfigurationEndpointFilterë¥¼ êµ¬ì„±í•˜ê³ , ì´ë¥¼ OAuth2 ì¸ì¦ ì„œë²„ SecurityFilterChain ë¹ˆì— ë“±ë¡
3. OidcProviderConfigurationEndpointFilterëŠ” OidcProviderConfiguration (Oidc Metadata) ì‘ë‹µì„ ì²˜ë¦¬

-----
### OpenID Connect 1.0 UserInfo Endpoint
-----
1. OidcUserinfoEndpointConfigurerëŠ” OpenID Connect 1.0 Userinfo ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì‚¬ìš©ìê°€ ì •ì˜í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µ
2. OidcUserinfoEndpointFilterë¥¼ êµ¬ì„±í•˜ê³ , OAuth2 ì¸ì¦ ì„œë²„ SecurityFilterChain ë¹ˆì— ë“±ë¡

-----
### OidcUserinfoEndpointFilter
-----
1. Userinfo ìš”ì²­ì„ ì²˜ë¦¬í•˜ê³ , OidcUserinfo ì‘ë‹µì„ ë°˜í™˜í•˜ëŠ” í•„í„°
2. ê¸°ë³¸ê°’
   - OidcUserinfoAuthenticationProvider : ìš”ì²­ëœ Scopeë¥¼ ê¸°ì¤€ìœ¼ë¡œ ID í† í°ì—ì„œ í‘œì¤€ í´ë ˆì„ì„ ì¶”ì¶œí•˜ëŠ” userInfoMapperë¥¼ ê°€ì§€ê³  ìˆìŒ

-----
### RequestMatcher
-----
: í† í° ê²€ì‚¬ ìš”ì²­ íŒ¨í„´ (GET /userinfo, POST /userinfo)

-----
### UserInfo ì—”ë“œí¬ì¸íŠ¸ ì ‘ê·¼ ì¡°ê±´
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/b5e5e852-7837-4e46-a735-5223c013e013">
</div>

1. ğŸ’¡ UserInfo ì—”ë“œí¬ì¸íŠ¸ í”„ë¡œí† ì½œì€ ê¸°ë³¸ì ìœ¼ë¡œ ì¸ì¦ì„ ë°›ì€ ìƒíƒœì—ì„œ ì ‘ê·¼ ê°€ëŠ¥
   - FilterSecurityInterceptor í´ë˜ìŠ¤ ì´í›„ì— ìœ„ì¹˜í•˜ê³  ìˆê¸° ë•Œë¬¸ì„ (FilterSecurityInterceptorëŠ” ìš”ì²­ì— ëŒ€í•œ ì¸ì¦ ê¶Œí•œì„ í™•ì¸í•˜ë¯€ë¡œ ì´ ì „ì— ì¸ì¦ì´ ë˜ì–´ì•¼í•¨)
2. UserInfo ì—”ë“œí¬ì¸íŠ¸ ìš”ì²­ ì‹œ, ì¼ë°˜ì ìœ¼ë¡œ ë¡œê·¸ì¸ ê³¼ì •ì„ ê±°ì¹˜ê¸° ë•Œë¬¸ì— ì •ìƒì ìœ¼ë¡œ Access Token ë°œê¸‰ ê°€ëŠ¥
3. ğŸ’¡ /userinfo ì—”ë“œí¬ì¸íŠ¸ëŠ” ê¶Œí•œ ë¶€ì—¬ íë¦„ ìš”ì²­ì—ì„œ ë°›ì€ Access Tokenì„ ê°€ì§€ê³  ì¸ê°€ ì„œë²„ë¡œ ìš”ì²­í•˜ê¸° ë•Œë¬¸ì—, ë³„ë„ì˜ ì¸ì¦ ê³¼ì •ì„ ê±°ì¹˜ë„ë¡ êµ¬ì„±ë˜ì–´ì ¸ì•¼ í•¨

-----
### UserInfo Endpoint ë³´í˜¸ ìì› êµ¬ì„±
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/e93d48e5-ef53-4a8f-b5aa-b3c92a4ebd77">
</div>

1. http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt) êµ¬ì„±ì„ í†µí•´ í† í°ì— ëŒ€í•œ ì¸ì¦ ê³¼ì •ì„ ê±°ì³ì•¼ í•¨ (ì¸ê°€ ì„œë²„ì—ì„œ ì‚¬ìš©ì ê³„ì •ì„ ê°€ì ¸ì˜¨ë‹¤ëŠ” ê²ƒì„ ìƒê° - ì¦‰, ì¸ì¦ ê°œë…[ì‚¬ìš©ìê°€ Access Tokenì„ ê°€ì§€ê³  ì˜¤ë¯€ë¡œ ì´ë¥¼ ì¸ì¦])
2. UserInfo ResourceëŠ” FilterSecurityInterceptorì—ì„œ ê¶Œí•œì´ í—ˆê°€ëœ ì´í›„ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë„ë¡ ìœ„ì¹˜
3. OpenID Connect 1.0 UserInfo ì—”ë“œí¬ì¸íŠ¸ì—ëŠ” í† í°ì„ ë””ì½”ë”©í•˜ê³ , ê²€ì¦í•˜ê¸° ìœ„í•´ JwtDecoder ë¹ˆì´ í•„ìš”

-----
### OpenID Connect 1.0 Userinfo Endpoint íë¦„ë„
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/8750adc2-6200-4d3f-9543-12ce1cec9a4b">
</div>

  - Requestì—ëŠ” Access Tokenì„ Headerì— ì €ì¥í•´ì„œ ì „ì†¡

-----
### ì½”ë“œ
-----
1. Authorization Server
   - AppConfig
```java
package io.security.oauth2.authorizationserver;

import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jose.proc.SecurityContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.OAuth2AuthorizationServerConfiguration;
import org.springframework.security.oauth2.core.AuthorizationGrantType;
import org.springframework.security.oauth2.core.ClientAuthenticationMethod;
import org.springframework.security.oauth2.core.oidc.OidcScopes;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.server.authorization.InMemoryOAuth2AuthorizationConsentService;
import org.springframework.security.oauth2.server.authorization.InMemoryOAuth2AuthorizationService;
import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationConsentService;
import org.springframework.security.oauth2.server.authorization.OAuth2AuthorizationService;
import org.springframework.security.oauth2.server.authorization.client.InMemoryRegisteredClientRepository;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClient;
import org.springframework.security.oauth2.server.authorization.client.RegisteredClientRepository;
import org.springframework.security.oauth2.server.authorization.config.ClientSettings;
import org.springframework.security.oauth2.server.authorization.config.ProviderSettings;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.time.Instant;
import java.util.Arrays;
import java.util.UUID;

@Configuration
public class AppConfig {

    @Bean
    public ProviderSettings providerSettings() {
        return ProviderSettings.builder().issuer("http://localhost:9000").build();
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {

        RegisteredClient registeredClient1 = getRegisteredClient("oauth2-client-app1", "{noop}secret1", "read", "write");
        RegisteredClient registeredClient2 = getRegisteredClient("oauth2-client-app2", "{noop}secret2", "read", "delete");
        RegisteredClient registeredClient3 = getRegisteredClient("oauth2-client-app3", "{noop}secret3", "read", "update");

        return new InMemoryRegisteredClientRepository(Arrays.asList(registeredClient1, registeredClient2, registeredClient3));

    }

    private RegisteredClient getRegisteredClient(String clientId, String clientSecret, String scope1, String scope2) {
        return RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId(clientId)
                .clientSecret(clientSecret)
                .clientName(clientId)
                .clientIdIssuedAt(Instant.now())
                .clientSecretExpiresAt(Instant.MAX)
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_POST)
                .clientAuthenticationMethod(ClientAuthenticationMethod.NONE)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8081")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .scope(OidcScopes.EMAIL)
                .scope(OidcScopes.ADDRESS)
                .scope(OidcScopes.PHONE) // OidcScope 5ê°œ
                .scope(scope1)
                .scope(scope2)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())
//                .tokenSettings(TokenSettings.builder().reuseRefreshTokens(false).build())
                .build();
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) { // Resource Serverì—ì„œ ìš”ì²­ë˜ëŠ” Access Tokenì„ ì²˜ë¦¬í•  JwtDecoder
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }
    
    @Bean
    public JWKSource<SecurityContext> jwkSource() throws NoSuchAlgorithmException {
        RSAKey rsaKey = generateRsa();
        JWKSet jwkSet = new JWKSet(rsaKey);

        return (jwkSelector, context) -> jwkSelector.select(jwkSet);
    }

    private RSAKey generateRsa() throws NoSuchAlgorithmException {

        KeyPair keyPair = generateKeyPair();
        RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();

        return new RSAKey.Builder(rsaPublicKey)
                .privateKey(rsaPrivateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
    }

    private KeyPair generateKeyPair() throws NoSuchAlgorithmException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        return keyPairGenerator.generateKeyPair();
    }

    @Bean
    public OAuth2AuthorizationService oAuth2AuthorizationService() {
        return new InMemoryOAuth2AuthorizationService();
    }

    @Bean
    public OAuth2AuthorizationConsentService oAuth2AuthorizationConsentService() {
        return new InMemoryOAuth2AuthorizationConsentService();
    }
}
```

   - AuthorizationServerConfig
```java
package io.security.oauth2.authorizationserver;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.oauth2.server.authorization.OAuth2AuthorizationServerConfigurer;
import org.springframework.security.config.annotation.web.configurers.oauth2.server.resource.OAuth2ResourceServerConfigurer;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.oauth2.server.authorization.authentication.OAuth2AuthorizationCodeRequestAuthenticationToken;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint;
import org.springframework.security.web.util.matcher.RequestMatcher;
import org.springframework.util.StringUtils;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Configuration(proxyBeanMethods = false)
public class AuthorizationServerConfig {

    @Autowired
    private CustomAuthenticationProvider customAuthenticationProvider;


    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer<HttpSecurity> authorizationServerConfigurer =
                new OAuth2AuthorizationServerConfigurer<>();
        RequestMatcher endpointsMatcher = authorizationServerConfigurer.getEndpointsMatcher();
        authorizationServerConfigurer.authorizationEndpoint(authorizationEndpoint ->
                authorizationEndpoint
                        .authenticationProvider(customAuthenticationProvider)
                        .authorizationResponseHandler(new AuthenticationSuccessHandler() {
                                                          @Override
                                                          public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
                                                              OAuth2AuthorizationCodeRequestAuthenticationToken authentication1 = (OAuth2AuthorizationCodeRequestAuthenticationToken) authentication;
                                                              System.out.println(authentication);
                                                              String redirectUri = authentication1.getRedirectUri();
                                                              String authorizationCode = authentication1.getAuthorizationCode().getTokenValue();
                                                              String state = null;
                                                              if (StringUtils.hasText(authentication1.getState())) {
                                                                  state = authentication1.getState();
                                                              }
                                                              response.sendRedirect(redirectUri + "?code=" + authorizationCode + "&state=" + state);
                                                          }
                                                      }
                        )
                        .errorResponseHandler(new AuthenticationFailureHandler() {
                            @Override
                            public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
                                System.out.println(exception.toString());
                                response.sendError(HttpServletResponse.SC_BAD_REQUEST);
                            }
                        })
        );

        http
                .requestMatcher(endpointsMatcher)
                .authorizeRequests(authorizeRequests ->
                        authorizeRequests.anyRequest().authenticated()
                )
                .csrf(csrf -> csrf.ignoringRequestMatchers(endpointsMatcher))
                .apply(authorizationServerConfigurer);
        http
                .exceptionHandling(exceptions ->
                        exceptions.authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint("/login"))
                );

        http.oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt); // Resource Serverì—ì„œ ìš”ì²­ë˜ëŠ” Access Tokenì„ ê²€ì¦í•  JwtDecoder ì„¤ì •
        return http.build();
    }
}
```

   - OidcConfigurer
```java
<B extends HttpSecurityBuilder<B>> void init(B builder) {
        OidcUserInfoEndpointConfigurer userInfoEndpointConfigurer = (OidcUserInfoEndpointConfigurer)this.getConfigurer(OidcUserInfoEndpointConfigurer.class); // OidcUserInfoEndpointConfigurer í˜¸ì¶œ
        userInfoEndpointConfigurer.init(builder); // OidcUserInfoEndpointConfigurer init() í˜¸ì¶œ
        OidcClientRegistrationEndpointConfigurer clientRegistrationEndpointConfigurer = (OidcClientRegistrationEndpointConfigurer)this.getConfigurer(OidcClientRegistrationEndpointConfigurer.class);
        if (clientRegistrationEndpointConfigurer != null) {
            clientRegistrationEndpointConfigurer.init(builder);
        }

        List<RequestMatcher> requestMatchers = new ArrayList();
        requestMatchers.add(new AntPathRequestMatcher("/.well-known/openid-configuration", HttpMethod.GET.name())); /// OIDC Metadata
        requestMatchers.add(userInfoEndpointConfigurer.getRequestMatcher());
        if (clientRegistrationEndpointConfigurer != null) {
            requestMatchers.add(clientRegistrationEndpointConfigurer.getRequestMatcher());
        }

        this.requestMatcher = new OrRequestMatcher(requestMatchers);
}

<B extends HttpSecurityBuilder<B>> void configure(B builder) {
        OidcUserInfoEndpointConfigurer userInfoEndpointConfigurer = (OidcUserInfoEndpointConfigurer)this.getConfigurer(OidcUserInfoEndpointConfigurer.class);
        userInfoEndpointConfigurer.configure(builder); // OidcUserInfoEndpointConfigurer configure() í˜¸ì¶œ
        OidcClientRegistrationEndpointConfigurer clientRegistrationEndpointConfigurer = (OidcClientRegistrationEndpointConfigurer)this.getConfigurer(OidcClientRegistrationEndpointConfigurer.class);
        if (clientRegistrationEndpointConfigurer != null) {
            clientRegistrationEndpointConfigurer.configure(builder);
        }

        ProviderSettings providerSettings = OAuth2ConfigurerUtils.getProviderSettings(builder);
        OidcProviderConfigurationEndpointFilter oidcProviderConfigurationEndpointFilter = new OidcProviderConfigurationEndpointFilter(providerSettings);
        builder.addFilterBefore((Filter)this.postProcess(oidcProviderConfigurationEndpointFilter), AbstractPreAuthenticatedProcessingFilter.class);
}
```

   - OidcUserInfoEndpointConfigurer
```java
<B extends HttpSecurityBuilder<B>> void init(B builder) {
        ProviderSettings providerSettings = OAuth2ConfigurerUtils.getProviderSettings(builder);
        String userInfoEndpointUri = providerSettings.getOidcUserInfoEndpoint();
        this.requestMatcher = new OrRequestMatcher(new RequestMatcher[]{new AntPathRequestMatcher(userInfoEndpointUri, HttpMethod.GET.name()), new AntPathRequestMatcher(userInfoEndpointUri, HttpMethod.POST.name())});
        OidcUserInfoAuthenticationProvider oidcUserInfoAuthenticationProvider = new OidcUserInfoAuthenticationProvider(OAuth2ConfigurerUtils.getAuthorizationService(builder)); // OidcUserInfoAuthenticationProvider ì •ì˜
        if (this.userInfoMapper != null) {
            oidcUserInfoAuthenticationProvider.setUserInfoMapper(this.userInfoMapper);
        }

        builder.authenticationProvider((AuthenticationProvider)this.postProcess(oidcUserInfoAuthenticationProvider));
}

<B extends HttpSecurityBuilder<B>> void configure(B builder) {
        AuthenticationManager authenticationManager = (AuthenticationManager)builder.getSharedObject(AuthenticationManager.class);
        ProviderSettings providerSettings = OAuth2ConfigurerUtils.getProviderSettings(builder);
        OidcUserInfoEndpointFilter oidcUserInfoEndpointFilter = new OidcUserInfoEndpointFilter(authenticationManager, providerSettings.getOidcUserInfoEndpoint()); // OidcUserInfoEndpointFilter ìƒì„±
        builder.addFilterAfter((Filter)this.postProcess(oidcUserInfoEndpointFilter), FilterSecurityInterceptor.class);
}
```

   - GET ```http://localhost:9000/oauth2/authorize?response_type=code&client_id=oauth2-client-app1&scope=openid read write address phone email&redirect_uri=http://127.0.0.1:8081```
   - POST ```http://localhost:9000/oauth2/token```
   - GET ```http://localhost:9000/userinfo```
   - BearerTokenAuthenticationFilter
```java
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String token;
        try {
            token = this.bearerTokenResolver.resolve(request);
        } catch (OAuth2AuthenticationException var10) {
            OAuth2AuthenticationException invalid = var10;
            this.logger.trace("Sending to authentication entry point since failed to resolve bearer token", invalid);
            this.authenticationEntryPoint.commence(request, response, invalid);
            return;
        }

        if (token == null) {
            this.logger.trace("Did not process request since did not find bearer token");
            filterChain.doFilter(request, response);
        } else {
            BearerTokenAuthenticationToken authenticationRequest = new BearerTokenAuthenticationToken(token);
            authenticationRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));

            try {
                AuthenticationManager authenticationManager = this.authenticationManagerResolver.resolve(request);
                Authentication authenticationResult = authenticationManager.authenticate(authenticationRequest); // JwtAuthenticationProvider
                SecurityContext context = SecurityContextHolder.createEmptyContext();
                context.setAuthentication(authenticationResult);
                SecurityContextHolder.setContext(context);
                this.securityContextRepository.saveContext(context, request, response); // ì¸ì¦ ê°ì²´ ì €ì¥
                if (this.logger.isDebugEnabled()) {
                    this.logger.debug(LogMessage.format("Set SecurityContextHolder to %s", authenticationResult));
                }

                filterChain.doFilter(request, response);
            } catch (AuthenticationException var9) {
                AuthenticationException failed = var9;
                SecurityContextHolder.clearContext();
                this.logger.trace("Failed to process authentication request", failed);
                this.authenticationFailureHandler.onAuthenticationFailure(request, response, failed);
            }

        }
}
```

   - JwtAuthenticationProvider
```java
public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        BearerTokenAuthenticationToken bearer = (BearerTokenAuthenticationToken)authentication;
        Jwt jwt = this.getJwt(bearer);
        AbstractAuthenticationToken token = (AbstractAuthenticationToken)this.jwtAuthenticationConverter.convert(jwt);
        token.setDetails(bearer.getDetails());
        this.logger.debug("Authenticated token");
        return token;
}

private Jwt getJwt(BearerTokenAuthenticationToken bearer) {
        try {
            return this.jwtDecoder.decode(bearer.getToken()); // JWT íƒ€ì… ê°ì²´ ë°˜í™˜ (í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ ë°›ìŒ)
        } catch (BadJwtException var3) {
            BadJwtException failed = var3;
            this.logger.debug("Failed to authenticate since the JWT was invalid");
            throw new InvalidBearerTokenException(failed.getMessage(), failed);
        } catch (JwtException var4) {
            JwtException failed = var4;
            throw new AuthenticationServiceException(failed.getMessage(), failed);
        }
}
```

   - OidcUserInfoEndpointFilter
```java
private static final String DEFAULT_OIDC_USER_INFO_ENDPOINT_URI = "/userinfo";

protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        if (!this.userInfoEndpointMatcher.matches(request)) {
            filterChain.doFilter(request, response);
        } else {
            try {
                Authentication principal = SecurityContextHolder.getContext().getAuthentication();
                OidcUserInfoAuthenticationToken userInfoAuthentication = new OidcUserInfoAuthenticationToken(principal);
                OidcUserInfoAuthenticationToken userInfoAuthenticationResult = (OidcUserInfoAuthenticationToken)this.authenticationManager.authenticate(userInfoAuthentication);
                this.sendUserInfoResponse(response, userInfoAuthenticationResult.getUserInfo());
            } catch (OAuth2AuthenticationException var11) {
                OAuth2AuthenticationException ex = var11;
                this.sendErrorResponse(response, ex.getError());
            } catch (Exception var12) {
                Exception ex = var12;
                OAuth2Error error = new OAuth2Error("invalid_request", "OpenID Connect 1.0 UserInfo Error: " + ex.getMessage(), "https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError");
                this.sendErrorResponse(response, error);
            } finally {
                SecurityContextHolder.clearContext();
            }

        }
}
```

   - OidcUserInfoAuthenticationProvider
```java
public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        OidcUserInfoAuthenticationToken userInfoAuthentication = (OidcUserInfoAuthenticationToken)authentication;
        AbstractOAuth2TokenAuthenticationToken<?> accessTokenAuthentication = null;
        if (AbstractOAuth2TokenAuthenticationToken.class.isAssignableFrom(userInfoAuthentication.getPrincipal().getClass())) {
            accessTokenAuthentication = (AbstractOAuth2TokenAuthenticationToken)userInfoAuthentication.getPrincipal();
        }

        if (accessTokenAuthentication != null && accessTokenAuthentication.isAuthenticated()) {
            String accessTokenValue = accessTokenAuthentication.getToken().getTokenValue(); // ì‚¬ìš©ìê°€ ë³´ë‚¸ Access Token ì¶”ì¶œ
            OAuth2Authorization authorization = this.authorizationService.findByToken(accessTokenValue, OAuth2TokenType.ACCESS_TOKEN); // ì¸ê°€ì„œë²„ê°€ ìµœì´ˆ í† í°ì„ ë°œê¸‰í•œ ê°ì²´ë¥¼ ê°€ì ¸ì˜´ 
            if (authorization == null) {
                throw new OAuth2AuthenticationException("invalid_token");
            } else {
                OAuth2Authorization.Token<OAuth2AccessToken> authorizedAccessToken = authorization.getAccessToken(); // ì¸ê°€ì„œë²„ê°€ ìµœì´ˆ í† í°ì„ ë°œê¸‰í•œ ê°ì²´ì—ì„œ Access Token ì¶”ì¶œ
                if (!authorizedAccessToken.isActive()) { // í™œì„±í™” ì—¬ë¶€ í™•ì¸
                    throw new OAuth2AuthenticationException("invalid_token");
                } else if (!((OAuth2AccessToken)authorizedAccessToken.getToken()).getScopes().contains("openid")) { // open_id í¬í•¨ ì—¬ë¶€ í™•ì¸
                    throw new OAuth2AuthenticationException("insufficient_scope");
                } else {
                    OAuth2Authorization.Token<OidcIdToken> idToken = authorization.getToken(OidcIdToken.class); // id_tokenì„ í™•ì¸ (open_idì´ë¯€ë¡œ id_token ì¡´ì¬)
                    if (idToken == null) {
                        throw new OAuth2AuthenticationException("invalid_token");
                    } else {
                        OidcUserInfoAuthenticationContext authenticationContext = OidcUserInfoAuthenticationContext.with(userInfoAuthentication).accessToken((OAuth2AccessToken)authorizedAccessToken.getToken()).authorization(authorization).build();
                        OidcUserInfo userInfo = (OidcUserInfo)this.userInfoMapper.apply(authenticationContext); // OidcUserInfo ê°ì²´ ìƒì„±
                        return new OidcUserInfoAuthenticationToken(accessTokenAuthentication, userInfo);
                    }
                }
            }
        } else {
            throw new OAuth2AuthenticationException("invalid_token");
        }
    }

...

    private static final class DefaultOidcUserInfoMapper implements Function<OidcUserInfoAuthenticationContext, OidcUserInfo> {
        private static final List<String> EMAIL_CLAIMS = Arrays.asList("email", "email_verified");
        private static final List<String> PHONE_CLAIMS = Arrays.asList("phone_number", "phone_number_verified");
        private static final List<String> PROFILE_CLAIMS = Arrays.asList("name", "family_name", "given_name", "middle_name", "nickname", "preferred_username", "profile", "picture", "website", "gender", "birthdate", "zoneinfo", "locale", "updated_at");

        private DefaultOidcUserInfoMapper() {
        }

        public OidcUserInfo apply(OidcUserInfoAuthenticationContext authenticationContext) {
            OAuth2Authorization authorization = authenticationContext.getAuthorization(); // OpenID Connectì— ëŒ€í•´ì„œëŠ” id_tokenì— í¬í•¨ë˜ëŠ” claims ì •ë³´ í¬í•¨
            OidcIdToken idToken = (OidcIdToken)authorization.getToken(OidcIdToken.class).getToken();
            OAuth2AccessToken accessToken = authenticationContext.getAccessToken();
            Map<String, Object> scopeRequestedClaims = getClaimsRequestedByScope(idToken.getClaims(), accessToken.getScopes()); // ì´ ì •ë³´ ì¤‘, openid ì „ìš© í´ë ˆì„ìœ¼ë¡œ Filtering
            return new OidcUserInfo(scopeRequestedClaims);
        }

       private static Map<String, Object> getClaimsRequestedByScope(Map<String, Object> claims, Set<String> requestedScopes) { // í† í°ì— í¬í•¨ë˜ì–´ìˆë‹¤ë©´, ì œê³µ
            Set<String> scopeRequestedClaimNames = new HashSet(32);
            scopeRequestedClaimNames.add("sub"); // í‘œì¤€
            if (requestedScopes.contains("address")) { // ë‚˜ë¨¸ì§€ëŠ” í˜„ì¬ ì „ìš© í´ë ˆì„ ì •ë³´ê°€ ì—†ìœ¼ë¯€ë¡œ ì‚­ì œ (ìœ„ ì½”ë“œ)
                scopeRequestedClaimNames.add("address");
            }

            if (requestedScopes.contains("email")) {
                scopeRequestedClaimNames.addAll(EMAIL_CLAIMS);
            }

            if (requestedScopes.contains("phone")) {
                scopeRequestedClaimNames.addAll(PHONE_CLAIMS);
            }

            if (requestedScopes.contains("profile")) {
                scopeRequestedClaimNames.addAll(PROFILE_CLAIMS);
            }

            Map<String, Object> requestedClaims = new HashMap(claims);
            requestedClaims.keySet().removeIf((claimName) -> {
                return !scopeRequestedClaimNames.contains(claimName); // ì „ìš© í´ë ˆì„ì´ í¬í•¨ë˜ì§€ ì•Šìœ¼ë©´ ì‚­ì œ
            });
            return requestedClaims; // subë§Œ ì¡´ì¬
       }

      ...

   }
}
```
```json
{
    "sub": "user"
}
```

   - ìµœì´ˆ ì„ì‹œ ì½”ë“œ ì‹œ, openidë¥¼ ë¯¸ í¬í•¨í•˜ê²Œ ë˜ë©´, ë‹¤ìŒê³¼ ê°™ìŒ (openidê°€ í¬í•¨ë˜ì§€ ì•Šì•„ë„, ê¸°ë³¸ ì‚¬ìš©ì ì •ë³´ëŠ” ì¶œë ¥ë˜ë„ë¡ ê°œì„ ë˜ì–´ì•¼ í•˜ëŠ” ê²ƒì´ ë§ìŒ)
```json
{
    "error": "insufficient_scope"
}
```
```java
else if (!((OAuth2AccessToken)authorizedAccessToken.getToken()).getScopes().contains("openid")) { // open_id í¬í•¨ ì—¬ë¶€ í™•ì¸
                    throw new OAuth2AuthenticationException("insufficient_scope");
}
```
